// <variant> -*- C++ -*-

// Copyright (C) 2016-2022 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file basic_variant
 *  This is the `<basic_variant>` C++ Library header.
 */

#ifndef _GLIBCXX_BASICVARIANT
#define _GLIBCXX_BASICVARIANT 1

#pragma GCC system_header

#if __cplusplus >= 201703L

#include <initializer_list>
#include <type_traits>
#include <variant>
#include <memory>
#include <bits/enable_special_members.h>
#include <bits/exception_defines.h>
#include <bits/functional_hash.h>
#include <bits/invoke.h>
#include <bits/parse_numbers.h>
#include <bits/stl_iterator_base_types.h>
#include <bits/stl_iterator_base_funcs.h>
#include <bits/stl_construct.h>
#include <bits/utility.h> // in_place_index_t
#if __cplusplus >= 202002L
# include <compare>
#endif

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _Alloc, typename... _Types> class basic_variant;
  
namespace __detail
{


namespace __basic_variant
{  
  template <typename... _Types, typename _Tp>
  _GLIBCXX20_CONSTEXPR
  decltype(auto)
  __variant_extract(_Tp&& __rhs)
  {
    if constexpr (is_lvalue_reference_v<_Tp>)
    {
      if constexpr (is_const_v<remove_reference_t<_Tp>>)
        return static_cast<const variant<_Types...>&>(__rhs.__variant);
      else
        return static_cast<variant<_Types...>&>(__rhs.__variant);
    }
      else
        return static_cast<variant<_Types...>&&>(__rhs.__variant);
  }
  
// meh, not much benefit from this other than defaulting the constructors
template <typename _Alloc>
struct __Alloc_wrapper
{
    _Alloc __alloc;
    typedef std::allocator_traits<_Alloc> __traits;
    
    constexpr __Alloc_wrapper() = default;
    constexpr __Alloc_wrapper(const __Alloc_wrapper& __other) 
    noexcept(std::is_nothrow_copy_constructible<_Alloc>::value)
    : __alloc(__traits::select_on_container_copy_construction(__other.__alloc)){};
    
    constexpr __Alloc_wrapper(__Alloc_wrapper&& __other)
    noexcept(std::is_nothrow_copy_constructible<_Alloc>::value)
    : __alloc(__other.__alloc){};
};

  
} // __basic_variant

namespace __variant
{

    // The __as function templates implement the exposition-only "as-variant"
   /* 
    template<typename Alloc, typename... _Types>
      constexpr std::variant<_Types...>&
      __as(std::basic_variant<Alloc, _Types...>& __v) noexcept
      { return __basic_variant::__variant_extract(__v); }
    
    template<typename Alloc, typename... _Types>
      constexpr const std::variant<_Types...>&
      __as(const std::basic_variant<Alloc, _Types...>& __v) noexcept
      { return __basic_variant::__variant_extract(__v); }
    
    template<typename Alloc, typename... _Types>
      constexpr std::variant<_Types...>&&
      __as(std::basic_variant<Alloc, _Types...>&& __v) noexcept
      { return std::move(__basic_variant::__variant_extract(__v)); }
    
    template<typename Alloc, typename... _Types>
      constexpr const std::variant<_Types...>&&
      __as(const std::basic_variant<Alloc, _Types...>&& __v) noexcept
      { return std::move(__basic_variant::__variant_extract(__v)); }
*/

}

} // __detail

template<typename _Tp, typename _Alloc>
concept _AllocAware = uses_allocator<_Tp, _Alloc>::value;


  template<typename _Alloc, typename... _Types>
    struct variant_size<basic_variant<_Alloc, _Types...>>
    : std::integral_constant<size_t, sizeof...(_Types)> {};

  
  template<typename _Alloc, typename... _Types>
    inline constexpr size_t
    variant_size_v<basic_variant<_Alloc, _Types...>> = sizeof...(_Types);

  template<typename _Alloc, typename... _Types>
    inline constexpr size_t
    variant_size_v<const basic_variant<_Alloc, _Types...>> = sizeof...(_Types);


  template<size_t _Np, typename _Alloc,  typename... _Types>
    struct variant_alternative<_Np, basic_variant<_Alloc, _Types...>>
    {
      static_assert(_Np < sizeof...(_Types));

      using type = typename _Nth_type<_Np, _Types...>::type;
    };

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>&
    get(basic_variant<_Alloc, _Types...>&);

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>&&
    get(basic_variant<_Alloc, _Types...>&&);

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>> const&
    get(const basic_variant<_Alloc, _Types...>&);

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>> const&&
    get(const basic_variant<_Alloc, _Types...>&&);


  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr bool
    holds_alternative(const basic_variant<_Alloc, _Types...>& __v) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      return __v.index() == std::__find_uniq_type_in_pack<_Tp, _Types...>();
    }

  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr _Tp&
    get(basic_variant<_Alloc, _Types...>& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      return std::get<__n>(__detail::__basic_variant::__variant_extract<_Types...>(__v));
    }

  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr _Tp&&
    get(basic_variant<_Alloc, _Types...>&& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      return std::get<__n>(std::move(__detail::__basic_variant::__variant_extract<_Types...>(__v)));
    }

  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr const _Tp&
    get(const basic_variant<_Alloc, _Types...>& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      return std::get<__n>(__detail::__basic_variant::__variant_extract<_Types...>(__v));
    }

  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr const _Tp&&
    get(const basic_variant<_Alloc, _Types...>&& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      return std::get<__n>(std::move(__detail::__basic_variant::__variant_extract<_Types...>(__v)));
    }

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr add_pointer_t<variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>>
    get_if(basic_variant<_Alloc, _Types...>* __ptr) noexcept
    {
      using _Alternative_type = variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>;
      static_assert(_Np < sizeof...(_Types),
		    "The index must be in [0, number of alternatives)");
      static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
      if (__ptr && __ptr->index() == _Np)
	return std::addressof(__detail::__variant::__get<_Np>(__detail::__basic_variant::__variant_extract<_Types...>(*__ptr)));
      return nullptr;
    }

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr
    add_pointer_t<const variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>>
    get_if(const basic_variant<_Alloc, _Types...>* __ptr) noexcept
    {
      using _Alternative_type = variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>;
      static_assert(_Np < sizeof...(_Types),
		    "The index must be in [0, number of alternatives)");
      static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
      if (__ptr && __ptr->index() == _Np)
	return std::addressof(__detail::__variant::__get<_Np>(__detail::__basic_variant::__variant_extract<_Types...>(*__ptr)));
      return nullptr;
    }

  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr add_pointer_t<_Tp>
    get_if(basic_variant<_Alloc, _Types...>* __ptr) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      return std::get_if<__n>(__ptr);
    }

  template<typename _Tp, typename _Alloc, typename... _Types>
    constexpr add_pointer_t<const _Tp>
    get_if(const basic_variant<_Alloc, _Types...>* __ptr) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      return std::get_if<__n>(__ptr);
    }


#define _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \
  template<typename _Alloc, typename... _Types> \
    constexpr bool operator __OP(const basic_variant<_Alloc, _Types...>& __lhs, \
				 const basic_variant<_Alloc, _Types...>& __rhs) \
    { \
      bool __ret = true; \
      __detail::__variant::__raw_idx_visit( \
        [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable \
        { \
	  if constexpr (__rhs_index != variant_npos) \
	    { \
	      if (__lhs.index() == __rhs_index) \
	        { \
		  auto& __this_mem = std::get<__rhs_index>(__lhs);	\
                  __ret = __this_mem __OP __rhs_mem; \
                } \
	      else \
		__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
            } \
          else \
            __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
	}, __detail::__basic_variant::__variant_extract<_Types...>(__rhs)); \
      return __ret; \
    }

  _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
  _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)
  _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)
  _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)
  _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)
  _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)

#undef _BASICVARIANT_RELATION_FUNCTION_TEMPLATE

 
#ifdef __cpp_lib_three_way_comparison
  template<typename _Alloc, typename... _Types>
    requires (three_way_comparable<_Types> && ...)
    constexpr
    common_comparison_category_t<compare_three_way_result_t<_Types>...>
    operator<=>(const basic_variant<_Alloc, _Types...>& __v, const basic_variant<_Alloc, _Types...>& __w)
    {
      common_comparison_category_t<compare_three_way_result_t<_Types>...> __ret
	= strong_ordering::equal;

      __detail::__variant::__raw_idx_visit(
	[&__ret, &__v] (auto&& __w_mem, auto __w_index) mutable
	{
	  if constexpr (__w_index != variant_npos)
	    {
	      if (__v.index() == __w_index)
		{
		  auto& __this_mem = std::get<__w_index>(__v);
		  __ret = __this_mem <=> __w_mem;
		  return;
		}
	    }
	  __ret = (__v.index() + 1) <=> (__w_index + 1);
	}, __w);
      return __ret;
    }

#endif



  template<typename _Alloc, typename... _Types>
    _GLIBCXX20_CONSTEXPR
    inline enable_if_t<(is_move_constructible_v<_Types> && ...)
			&& (is_swappable_v<_Types> && ...)>
    swap(basic_variant<_Alloc, _Types...>& __lhs, basic_variant<_Alloc, _Types...>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }

  template<typename _Alloc, typename... _Types>
    enable_if_t<!((is_move_constructible_v<_Types> && ...)
		   && (is_swappable_v<_Types> && ...))>
    swap(basic_variant<_Alloc, _Types...>&, basic_variant<_Alloc, _Types...>&) = delete;

 
  template<typename _Alloc, typename... _Types>
    class basic_variant
    {
    private:
      
      using _Variant = std::variant<_Types...>;
      
      
      template <typename... _UTypes>
      using  _Variadic_union = __detail::__variant::_Variadic_union<_UTypes...>; 
      
      std::__detail::__basic_variant::__Alloc_wrapper<_Alloc>   __aw;
      _Variant                                __variant;
      
      
      template <typename... _UTypes, typename _Tp>
	friend _GLIBCXX20_CONSTEXPR decltype(auto)
      std::__detail::__basic_variant::__variant_extract(_Tp&&);
      
      template<size_t _Np, typename _Vp>
    friend constexpr decltype(auto)
    __detail::__variant::__get(_Vp&& __v) noexcept;

      static_assert(sizeof...(_Types) > 0,
		    "variant must have at least one alternative");
      static_assert(!(std::is_reference_v<_Types> || ...),
		    "variant must have no reference alternative");
      static_assert(!(std::is_void_v<_Types> || ...),
		    "variant must have no void alternative");

      template<typename _Tp>
      static constexpr bool __not_self
        = !is_same_v<__remove_cvref_t<_Tp>, basic_variant>;
      
      template<typename _Tp>
      static constexpr bool
      __exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;

      template<typename _Tp>
      static constexpr size_t __accepted_index
        = __detail::__variant::__accepted_index<_Tp, _Variant>::value;

      template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
	  using __to_type = typename _Nth_type<_Np, _Types...>::type;

      template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
      using __accepted_type = __to_type<__accepted_index<_Tp>>;

      template<typename _Tp>
      static constexpr size_t __index_of
        = std::__find_uniq_type_in_pack<_Tp, _Types...>();
      
      using _Traits = __detail::__variant::_Traits<_Types...>;
      using __alloc_traits = std::allocator_traits<_Alloc>;

      template<typename _Tp>
	struct __is_in_place_tag : false_type { };
      template<typename _Tp>
	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
      template<size_t _Np>
	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };

      template<typename _Tp>
	static constexpr bool __not_in_place_tag
	  = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;
      
     
      constexpr const _Variadic_union<_Types...>& _M_get_u() const & noexcept
      { return __variant._M_get_u(); }

      constexpr _Variadic_union<_Types...>& _M_get_u() & noexcept
      { return __variant._M_get_u(); }

      constexpr const _Variadic_union<_Types...>&& _M_get_u() const && noexcept
      { return std::move(__variant._M_get_u()); }

      constexpr _Variadic_union<_Types...>&& _M_get_u() && noexcept
      { return std::move(__variant._M_get_u()); }
      
      

    public:
//non allocator extended constructors default the allocator      
      // default constructors rely on the alternative doing the right thing
      // allocator wise for the type in question
      basic_variant() = default;
      basic_variant(const basic_variant& __rhs) = default;
      basic_variant(basic_variant&&) = default;            
      _GLIBCXX20_CONSTEXPR ~basic_variant() = default;

// non allocator aware types just forward to the variant object
      template<typename _Tp,
	       typename = enable_if_t<sizeof...(_Types) != 0>,
	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
	       typename _Tj = __accepted_type<_Tp&&>,
	       typename = enable_if_t<is_constructible_v<_Variant, _Tp>>>
	constexpr
	basic_variant(_Tp&& __t) 
	noexcept(is_nothrow_constructible_v<_Variant, _Tp>)
    :__variant(std::make_from_tuple<_Variant>(
        std::tuple_cat(std::forward_as_tuple(std::in_place_index<__accepted_index<_Tp>>),
        std::uses_allocator_construction_args<_Tj>(__aw.__alloc, std::forward<_Tp>(__t)))))
	{ }

      template<typename _Tp, typename... _Args,
	       typename = enable_if_t<is_constructible_v<_Variant, in_place_type_t<_Tp>, _Args...>>>
	constexpr explicit
	basic_variant(in_place_type_t<_Tp>, _Args&&... __args) 
	: __variant(std::make_from_tuple<_Variant>(
        std::tuple_cat(forward_as_tuple(in_place_index<__index_of<_Tp>>),
            std::uses_allocator_construction_args<_Tp>(__aw.__alloc, std::forward<_Args>(__args)...))))
	{ }

      template<typename _Tp, typename _Up, typename... _Args,
	       typename = enable_if_t<is_constructible_v<_Variant,
	                   in_place_type_t<_Tp>,
					   initializer_list<_Up>&, _Args...>>>
	constexpr explicit
	basic_variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
		_Args&&... __args) 
	: __variant(std::make_from_tuple<_Variant>(
        std::tuple_cat(forward_as_tuple(in_place_index<__index_of<_Tp>>),
        std::uses_allocator_construction_args<_Tp>(__aw.__alloc, __il,
            std::forward<_Args>(__args)...))))
	{ }

      template<size_t _Np, typename... _Args,
	       typename _Tp = __to_type<_Np>,
	       typename = enable_if_t<is_constructible_v<_Variant,
	                                                 in_place_index_t<_Np>, 
	                                                 _Args...>>>
	constexpr explicit
	basic_variant(in_place_index_t<_Np>, _Args&&... __args)
	: __variant(std::make_from_tuple<_Variant>(
        std::tuple_cat(forward_as_tuple(in_place_index<_Np>),
        std::uses_allocator_construction_args<_Tp>(__aw.__alloc,
            std::forward<_Args>(__args)...))))
	{ }

      template<size_t _Np, typename _Up, typename... _Args,
	       typename _Tp = __to_type<_Np>,
	       typename = enable_if_t<is_constructible_v<_Variant,
	                                                 in_place_index_t<_Np>,
	                                                 initializer_list<_Up>&,
	                                                 _Args...>>>
	constexpr explicit
	basic_variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
		_Args&&... __args)
	: __variant(std::make_from_tuple<_Variant>(
        std::tuple_cat(forward_as_tuple( in_place_index<_Np>),
        std::uses_allocator_construction_args<_Tp>(__aw.__alloc,__il,
            std::forward<_Args>(__args)...))))
	{ }

	
	      
      constexpr basic_variant& operator=(const basic_variant& __rhs)
      noexcept(is_nothrow_copy_assignable_v<_Variant>)
      requires (is_copy_assignable_v<_Variant>)
      {
        if constexpr (__alloc_traits::propagate_on_container_copy_assignment::value
                                     && !(__alloc_traits::is_always_equal::value))
        {
           if (get_allocator() != __rhs.get_allocator())
           {
             __aw.__alloc =  __rhs.get_allocator();
             if ( __rhs.index() == __variant.index()
                 || __rhs.index() ==variant_npos)
             {
               __variant = __rhs; 
             }
             else
             {
               __detail::__variant::__raw_idx_visit(
                 [this](auto&& __rhs_mem, auto __rhs_index) mutable
                 {
                   using _Tj = typename _Nth_type<__rhs_index, _Types...>::type;
                   if constexpr (is_nothrow_copy_constructible_v<_Tj>
                         || !is_nothrow_move_constructible_v<_Tj>)
                         this->emplace(__rhs_mem);
                   else
                   {
                       this->operator=(basic_variant(
                               std::allocator_arg,
                               __aw.__alloc,
                               in_place_index<_Tj>, __rhs_mem));
                   }
                 }, __rhs.__variant);
             }
           }
           else __variant = __rhs.__variant;
        }
        else __variant = __rhs.__variant;
        
        return *this;
      }
      constexpr basic_variant& operator=(const basic_variant& __rhs)
            requires (!is_copy_assignable_v<_Variant>) = delete;
      
      constexpr basic_variant& operator=(basic_variant&& __rhs)
      noexcept(is_nothrow_move_assignable_v<_Variant>)
      requires (is_move_assignable_v<_Variant>)
      {
        if constexpr (__alloc_traits::propagate_on_container_move_assignment::value
                                     && !(__alloc_traits::is_always_equal::value))
        {
           if (get_allocator() != __rhs.get_allocator())
           {
             __aw.__alloc =  __rhs.get_allocator();
             if ( __rhs.index() == __variant.index()
                 || __rhs.index() == variant_npos)
             {
               __variant = std::move(__rhs); 
             }
             else
             {
               __detail::__variant::__raw_idx_visit(
                 [this](auto&& __rhs_mem, auto __rhs_index) mutable
                 {
                   using _Tj = typename _Nth_type<__rhs_index, _Types...>::type;
                   if constexpr (is_nothrow_move_constructible_v<_Tj>)
                         this->emplace(std::move(__rhs_mem));
                   else
                   {
                       this->operator=(basic_variant(
                               std::allocator_arg,
                               __aw.__alloc,
                               in_place_index<_Tj>, std::move(__rhs_mem)));
                   }
                 }, __rhs.__variant);
             }
           }
           else __variant = std::move(__rhs.__variant);
        }
        else __variant = std::move(__rhs.__variant);
        
        return *this;
      }

      constexpr basic_variant& operator=(basic_variant&& __rhs)
                  requires (!is_move_assignable_v<_Variant>) = delete;
	
      template<typename _Tp>
	_GLIBCXX20_CONSTEXPR
	enable_if_t<is_assignable_v<_Variant&, _Tp>,
		    basic_variant&>
	operator=(_Tp&& __rhs)
	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
		 && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
	{
        // No allocator propagation. For POCMA==true, this is no different
        // to element of vector being assigned to. Ville is happy. Nina
        // is still on the fence as variant and vector are not the same :
        // variant's allocator *is* the allocator of the alternative, but 
        // Ville knows best so she is probably wrong.
	  constexpr auto __index = __accepted_index<_Tp>;
	  if (index() == __index)
	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
	  else
	    {
	      using _Tj = __accepted_type<_Tp&&>;
	      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
			    || !is_nothrow_move_constructible_v<_Tj>)
		this->emplace<__index>(std::forward<_Tp>(__rhs));
	      else
		operator=(variant(std::forward<_Tp>(__rhs)));
	    }
	  return *this;
	}

      template<typename _Tp, typename... _Args>
	_GLIBCXX20_CONSTEXPR
	enable_if_t<is_constructible_v<_Tp, _Args...> && 
	            __exactly_once<_Tp>,
		    _Tp&>
	emplace(_Args&&... __args)
	{
	  constexpr size_t __index = __index_of<_Tp>;
	  return std::apply([this](auto&&... __xs) -> decltype(auto) {
	              return __variant.template emplace<__index>(std::forward<decltype(__xs)>(__xs)...);
	          }, std::uses_allocator_construction_args<_Tp>(__aw.__alloc, std::forward<_Args>(__args)...));
	}

      template<typename _Tp, typename _Up, typename... _Args>
	_GLIBCXX20_CONSTEXPR
	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>
		    && __exactly_once<_Tp>,
		    _Tp&>
	emplace(initializer_list<_Up> __il, _Args&&... __args)
	{
        constexpr size_t __index = __index_of<_Tp>;
       return std::apply([this](auto&&... __xs) -> decltype(auto) {
                   return __variant.template emplace<__index>(std::forward<decltype(__xs)>(__xs)...);
               }, std::uses_allocator_construction_args<_Tp>(__aw.__alloc, __il, std::forward<_Args>(__args)...));
	}

      template<size_t _Np, typename... _Args>
	_GLIBCXX20_CONSTEXPR
	enable_if_t<is_constructible_v<__to_type<_Np>, _Args...>,
		    __to_type<_Np>&>
	emplace(_Args&&... __args)
	{
	  return this->emplace<__to_type<_Np>>(std::forward<_Args>(__args)...);
	}

      template<size_t _Np, typename _Up, typename... _Args>
	_GLIBCXX20_CONSTEXPR
	enable_if_t<is_constructible_v<__to_type<_Np>,
				       initializer_list<_Up>&, _Args...>,
		    __to_type<_Np>&>
	emplace(initializer_list<_Up> __il, _Args&&... __args)
	{
        return this->emplace<__to_type<_Np>>(__il, std::forward<_Args>(__args)...);
	}

      template<size_t _Np, typename... _Args>
	enable_if_t<!(_Np < sizeof...(_Types))> emplace(_Args&&...) = delete;

      template<typename _Tp, typename... _Args>
	enable_if_t<!__exactly_once<_Tp>> emplace(_Args&&...) = delete;

      constexpr bool valueless_by_exception() const noexcept
      { return __variant.valueless_by_exception(); }

      constexpr size_t index() const noexcept
      {
        return __variant.index(); 
      }

      _GLIBCXX20_CONSTEXPR
      void
      swap(basic_variant& __rhs)
      noexcept((__is_nothrow_swappable<_Types>::value && ...)
	       && is_nothrow_move_constructible_v<basic_variant>)
      {
        static_assert((is_move_constructible_v<_Types> && ...));

        if constexpr (__alloc_traits::propagate_on_container_swap::value
                                             && !(__alloc_traits::is_always_equal::value))
        {
           if (__aw.__alloc != __rhs.get_allocator())
           {
             using std::swap;
             swap(__aw.__alloc, __rhs.__aw.__alloc);
             
           }
        }
		
        // Handle this here to simplify the visitation.
        if (__rhs.valueless_by_exception()) [[__unlikely__]]
        {
          if (!this->valueless_by_exception()) [[__likely__]]
            __rhs.swap(*this);
          return;
        } 
        
        __detail::__variant::__raw_idx_visit(
            [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable
            {
              constexpr size_t __j = __rhs_index;
              if constexpr (__j != variant_npos)
	          {
                  if (this->index() == __j)
                  {
                    using std::swap;
                    swap(std::get<__j>(*this), __rhs_mem);
                  }
                  else
                  {
                      auto __tmp(std::move(__rhs_mem));

                      __detail::__variant::__raw_idx_visit(
                        [&__rhs](auto&& __this_mem, auto __this_index) mutable
                        {
                          constexpr size_t __k = __this_index;
                          if constexpr (__k != variant_npos)
			              __rhs.emplace<__k>(std::move(__this_mem));
                        }, __variant);

                      this->emplace<__j>(std::move(__tmp));
                  }
	          }
            }, __rhs.__variant);
      }


#define _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
      template<typename... _Tp> \
	friend constexpr bool \
	operator __OP(const basic_variant<_Tp...>& __lhs, \
		      const basic_variant<_Tp...>& __rhs);

      _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(<)
      _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(<=)
      _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(==)
      _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(!=)
      _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(>=)
      _BASICVARIANT_RELATION_FUNCTION_TEMPLATE(>)

#undef _BASICVARIANT_RELATION_FUNCTION_TEMPLATE
      
      
      constexpr _Alloc
      get_allocator() const noexcept 
      { 
          return __aw.__alloc;
      }

    };

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>&
    get(basic_variant<_Alloc, _Types...>& __v)
    {
      return get<_Np>(__detail::__basic_variant::__variant_extract<_Types...>(__v));
    }

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>&&
    get(basic_variant<_Alloc, _Types...>&& __v)
    {
      return get<_Np>(std::move(__detail::__basic_variant::__variant_extract<_Types...>(__v)));
    }

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr const variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>&
    get(const basic_variant<_Alloc, _Types...>& __v)
    {
      return get<_Np>(__detail::__basic_variant::__variant_extract<_Types...>(__v));
    }

  template<size_t _Np, typename _Alloc, typename... _Types>
    constexpr const variant_alternative_t<_Np, basic_variant<_Alloc, _Types...>>&&
    get(const basic_variant<_Alloc, _Types...>&& __v)
    {
      return get<_Np>(std::move(__detail::__basic_variant::__variant_extract<_Types...>(__v)));
    }

/*

  template<typename _Visitor, typename... _Variants>
    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
    visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      namespace __variant = std::__detail::__variant;

      if ((__variant::__as(__variants).valueless_by_exception() || ...))
	__throw_bad_variant_access("std::visit: variant is valueless");

      using _Result_type
	= __detail::__variant::__visit_result_t<_Visitor, _Variants...>;

      using _Tag = __detail::__variant::__deduce_visit_result<_Result_type>;

      if constexpr (sizeof...(_Variants) == 1)
	{
	  using _Vp = decltype(__variant::__as(std::declval<_Variants>()...));

	  constexpr bool __visit_rettypes_match = __detail::__variant::
	    __check_visitor_results<_Visitor, _Vp>(
	      make_index_sequence<variant_size_v<remove_reference_t<_Vp>>>());
	  if constexpr (!__visit_rettypes_match)
	    {
	      static_assert(__visit_rettypes_match,
			  "std::visit requires the visitor to have the same "
			  "return type for all alternatives of a variant");
	      return;
	    }
	  else
	    return std::__do_visit<_Tag>(
	      std::forward<_Visitor>(__visitor),
	      static_cast<_Vp>(__variants)...);
	}
      else
	return std::__do_visit<_Tag>(
	  std::forward<_Visitor>(__visitor),
	  __variant::__as(std::forward<_Variants>(__variants))...);
    }

#if __cplusplus > 201703L
  template<typename _Res, typename _Visitor, typename... _Variants>
    constexpr _Res
    visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      namespace __variant = std::__detail::__variant;

      if ((__variant::__as(__variants).valueless_by_exception() || ...))
	__throw_bad_variant_access("std::visit<R>: variant is valueless");

      return std::__do_visit<_Res>(std::forward<_Visitor>(__visitor),
	  __variant::__as(std::forward<_Variants>(__variants))...);
    }
#endif

  template<typename... _Types, size_t... __indices>
      struct _Variant_hash_base<basic_variant<_Types...>,
                    std::index_sequence<__indices...>>
      : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
  
  /// @cond undocumented
  template<bool, typename... _Types>
    struct __basic_variant_hash_call_base_impl
    {
      size_t
      operator()(const basic_variant<_Types...>& __t) const
      noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> && ...))
      {
	size_t __ret;
	__detail::__variant::__raw_visit(
	  [&__t, &__ret](auto&& __t_mem) mutable
	  {
	    using _Type = __remove_cvref_t<decltype(__t_mem)>;
	    if constexpr (!is_same_v<_Type,
			             __detail::__variant::__variant_cookie>)
	      __ret = std::hash<size_t>{}(__t.index())
		      + std::hash<_Type>{}(__t_mem);
	    else
	      __ret = std::hash<size_t>{}(__t.index());
	  }, __t);
	return __ret;
      }
    };

  template<typename... _Types>
    struct __variant_hash_call_base_impl<false, _Types...> {};

  template<typename... _Types>
    using __variant_hash_call_base =
    __variant_hash_call_base_impl<(__poison_hash<remove_const_t<_Types>>::
				   __enable_hash_call &&...), _Types...>;
  /// @endcond
*/
  template<typename... _Types>
    struct hash<basic_variant<_Types...>>
    : private hash<variant<_Types...>>      
    {
        using _Base = hash<variant<_Types...>>;
        size_t
        operator()(const basic_variant<_Types...>& __t) const
        noexcept(hash<variant<_Types...>>::operator())
        {
          return _Base::operator()(__t.__get_variant());
        }
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++17

#endif // _GLIBCXX_BASICVARIANT
